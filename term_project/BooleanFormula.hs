module BooleanFormula where

import BooleanSyntax
import Formula
import Data.List
import System.Random
import Control.Monad.State

-- Этот модуль посвящен работе с булевыми формулами в отличие от
-- Formula.hs, который работает с формулами общего вида.

-------------------------------------------------
-- 1. Проверка принадлежности формул классам Поста
-------------------------------------------------

-- Литература

-- Гаврилов Г.П., Сапоженко А.А. Задачи и упражнения по дискретной
-- математике. М.: Физматлит, 2005.

-- Проверка на сохранение констант: с. 72.

-- Проверка на самодвойственность: с. 64.

-- Проверка на монотонность: с. 76.

-- Проверка на линейность: с. 53, п. 2: "Метод [построения полинома
-- Жегалкина], базирующийся на преобразовании вектора значений функции".
-- Альтернативно см. https://ru.wikipedia.org/wiki/Полином_Жегалкина.
-- Раздел "Метод БПФ" описывает тот же метод, что и в задачнике.
-- Можно также использовать метод треугольника.

-- Примеры формул form1 и form2, определенные в модуле Formula,
-- доступны и здесь при условии, что импорт из BooleanSyntax в модуле
-- Formula не ограничен, то есть строка после "import BooleanSyntax" в
-- Formula.hs остается закомментированной.

-- Задание 1. Напишите функцию, которая возвращает True тогда и только
-- тогда, когда булева функция, определяемая формулой-аргументом,
-- сохраняет значение False. Обратите внимание, что сохранять False не
-- то же самое, что принимать False на всех аргументах.

preservesFalse :: Eq a => Formula a -> Bool
preservesFalse = undefined

-- Задание 2. Напишите функцию, которая возвращает True тогда и только
-- тогда, когда булева функция, определяемая формулой-аргументом,
-- сохраняет значение True. Обратите внимание, что сохранять True не
-- то же самое, что принимать True на всех аргументах.

preservesTrue :: Eq a => Formula a -> Bool
preservesTrue = undefined

-- Задание 3. Напишите функцию, которая возвращает True тогда и только
-- тогда, когда булева функция, определяемая формулой-аргументом,
-- самодвойственна.

selfDual :: Eq a => Formula a -> Bool
selfDual = undefined

-- Задание 4. Напишите функцию, которая возвращает True тогда и только
-- тогда, когда булева функция, определяемая формулой-аргументом,
-- монотонна. Обратите внимание, что тип [a] является экземпляром класса
-- Ord при условии, что тип a является экземпляром этого класса, однако
-- порядок на списках определен лексикографически. Скорее всего, это не
-- то, что нужно использовать в этой функции.

monotone :: Eq a => Formula a -> Bool
monotone = undefined

-- Задание 5. Напишите функцию, которая возвращает True тогда и только
-- тогда, когда булева функция, определяемая формулой-аргументом,
-- линейна.

linear :: Eq a => Formula a -> Bool
linear = undefined

-------------------------------------------------
-- 2. Генерирование случайных формул
-------------------------------------------------

-- Задание 6. Напишите функцию chooseAction actions k, которая
-- принимает список действий actions, каждое из которых снабжено
-- положительным весом, а также число k. Веса определяют распределение
-- вероятностей для действий: если actions = [(p1, a1), ..., (pn, an)]
-- и P = p1 + ... + pn, то действие aj происходит с вероятностью pj/P.
-- Формально chooseAction [(p1, a1), ..., (pn, an)] k возвращает aj,
-- такое что sum_{i=1}^{j-1} pi <= k < sum_{i=1}^j pi. Это не значит,
-- что код должен проверять это условие буквально. Функция должна
-- проходить список один раз.

-- Пример:
-- > map (chooseAction [(2, 1), (3, 2), (1, 3)]) [0..5]
-- [1,1,2,2,2,3]

-- Данная функция не использует случайные числа, а действия могут быть
-- значениями любого типа, не обязательно монадного.
-- Предусловия: n > 0, p1 > 0, ..., pn > 0, 0 <= k < sum_{i=1}^n pi.

chooseAction :: (Ord p, Num p) => [(p, a)] -> p -> a
chooseAction = undefined

-- Случайное действие, возвращающее значение типа a.

type R a = State StdGen a

-- randomRange (x, y) возвращает случайное число от x до y включительно.

randomRange :: Random a => (a, a) -> R a
randomRange range = state (randomR range)

-- Задание 7. Напишите функцию frequency, которая принимает список
-- взвешенных действий типа R a, как в chooseAction, и возвращает одно
-- из этих действий случайным образом в соответствии с распределением
-- вероятностей.

frequency :: [(Int, R a)] -> R a
frequency = undefined

-- Задание 8. Напишите функцию randomVar, такую что randomVar n
-- возвращает случайным образом одну из переменных V 0, ..., V (n-1).
-- Сложность по времени и по памяти не должна зависеть от n.
-- Предусловие: n > 0.

randomVar :: Int -> R (Formula Int)
randomVar = undefined

-- Задание 9. Напишите функцию randomConst, которая возвращает
-- случайную формулу-константу.

randomConst :: R (Formula a)
randomConst = undefined

-- Задание 10. Напишите функцию randomBin, которая возвращает
-- случайную бинарную связку. Все связки равновероятны.

randomBin :: R Op
randomBin = undefined

-- Задание 11. Напишите функцию rf, которая возвращает случайную формулу.
-- Первый аргумент: максимальная глубина формулы.
-- Второй аргумент: максимальное количество переменных в формуле.
-- Формула должна содержать в среднем 1 константу (T или F) на 9 переменных
-- и 1 отрицание на 5 бинарных связок.

rf :: Int -> Int -> R (Formula Int)
rf = undefined

-- Обертка для запуска. Принимает случайное действие и начальное значение
-- для генератора случайных чисел. Возвращает псевдослучайное значение.

runR :: R a -> Int -> a
runR action seed = fst (runState action (mkStdGen seed))

-- Для тестирования. Напоминание: печатать формулу следует функцией display.

randomFormula :: Int -> Int -> Int -> Formula Int
randomFormula depth vars seed = runR (rf depth vars) seed
